"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const color_1 = require("@heroku-cli/color");
const command_1 = require("@heroku-cli/command");
const cli_ux_1 = require("cli-ux");
class DomainsUpdate extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(DomainsUpdate);
        const { hostname } = args;
        try {
            cli_ux_1.default.action.start(`Updating ${color_1.color.cyan(hostname)} to use ${color_1.color.cyan(flags['cert-id'])} certificate`);
            await this.heroku.patch(`/apps/${flags.app}/domains/${hostname}`, {
                headers: {
                    Accept: 'application/vnd.heroku+json; version=3.allow_multiple_sni_endpoints',
                },
                body: { sni_endpoint: flags['cert-id'] },
            });
        }
        catch (error) {
            cli_ux_1.default.error(error);
        }
        finally {
            cli_ux_1.default.action.stop();
        }
    }
}
exports.default = DomainsUpdate;
DomainsUpdate.description = 'update a domain to use a different SSL certificate on an app';
DomainsUpdate.examples = ['heroku domains:update www.example.com --cert-id mycert'];
DomainsUpdate.hidden = true;
DomainsUpdate.flags = {
    help: command_1.flags.help({ char: 'h' }),
    app: command_1.flags.app({ required: true }),
    remote: command_1.flags.remote(),
    'cert-id': command_1.flags.string({ required: true }),
};
DomainsUpdate.args = [{ name: 'hostname' }];
